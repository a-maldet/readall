% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file_definition.R
\name{new_file_definition_excel_}
\alias{new_file_definition_excel_}
\title{Helper function for \code{new_file_definition_excel()}}
\usage{
new_file_definition_excel_(
  file_path,
  specification_files = NULL,
  range = NULL,
  sheet,
  cols = NULL,
  col_names = NULL,
  col_types = NULL,
  file_meta = NULL,
  header,
  skip_rows,
  na,
  trim_ws,
  n_max,
  to_lower,
  rename_cols,
  adapters = new_adapters(),
  cols_keep,
  extra_col_name = NULL,
  extra_col_val = NULL,
  extra_col_file_path,
  err_h,
  ...
)
}
\arguments{
\item{file_path}{A string holding the path to the data file.}

\item{specification_files}{An optional character vector holding the paths
to the files, where the file structure is described.}

\item{range}{An optional string, holding an EXCEL range string, defining the
data range in the spread sheet. If \code{header} is set to \code{TRUE}, then
the range must include a header row.}

\item{sheet}{A string or an integer number:
\itemize{
\item string: The value defines the name of the sheet, which should be read.
\item integer: The value defines the position of the sheet, which should be read.
(start counting with \code{1}).
}}

\item{cols}{An optional list argument, holding the column definitions.
This argument can be used instead of the arguments
\code{col_names}, \code{col_types}, \code{col_start}, \code{col_end}, \code{col_widths}, in order
to define the column structure. If the argument \code{cols} is used, then
non of the \verb{col_*} argument are allowed. If so, the \code{cols} argument
has the following structure: It is list, where each list entry fully describes
a single column. Each list entry must have the same subselection of the
following possible list entries:
\itemize{
\item \code{type}: (obligatoric) A string value defining the data type of the column.
The following values are allowed: \code{"character"}, \code{"logical"}, \code{"integer"},
\code{"numeric"} and \code{"NULL"} (for skipping this column). In the case of SAS files
the \code{type} information can be omitted, since the data type information
is stored in the SAS data files, but the argument \code{type} can still
be useful in order to check that the read data column have the expected
data type. For SAS-Files this check is done automatically after reading
the data with \code{\link[=read_data]{read_data()}}.
\item \code{name}: (optional) A string holding the column name.
\item \code{start}: (optional) A number holding the position of the first character of the column.
\item \code{end}: (optional) A number holding the position of the last character of the column.
\item \code{width} (optional) A numeric holding the number characters of the column.
\item \code{col_meta}: (optional) A \link[=new_col_meta]{col_meta} class object, holding some
meta information for the specific column (column description,
possible column values + descriptions of possible column values).
For details see section \strong{meta information}.
}}

\item{col_names}{An optional character vector holding the names of the columns.
If omitted, then the strings \code{"x1"}, \code{"x2"}, ... will be used.
In the case of DSV or EXCEL files: If the argument \code{header} is
set to \code{TRUE}, then the column names given
in the data header will be used instead. If \code{col_names} is also supplied,
then the column names given in the DSV, EXCEL or SAS file will be compared
with the names given in \code{col_names}. Sometimes it is useful, to have the
column names to be automatically transformed to lower case (directly after
reading the date, but before comparing the column names). This can be
achieved by setting \code{to_lower = TRUE}.
Generally, the argument \code{cols} can be used instead, in order to define
the column names. If the argument \code{cols} is not \code{NULL},
then the argument \code{col_names} must be omitted.}

\item{col_types}{A character vector defining the data types for each column.
The following strings are allowed: \code{"character"}, \code{"logical"},
\code{"integer"}, \code{"numeric"} and \code{"NULL"} (for skipping this column).
Generally, the argument \code{cols} can be used instead, in order to define
the column types. If the argument \code{cols} is not \code{NULL},
then the argument \code{col_types} must be omitted. In the case of SAS files
the \code{col_types} information can be omitted, since the data type information
is stored in the SAS data files, but the argument \code{col_types} can still
be useful in order to check the read data files, if the data types are
as expected. For SAS-Files this check is done automatically after reading
the data with \code{\link[=read_data]{read_data()}}}

\item{file_meta}{An optional \link[=new_file_meta]{file_meta} class object,
holding some meta information for each data column
(column description, possible column values + descriptions of possible
column values).
For details see section \strong{meta information}.
If the argument \code{cols} is not \code{NULL}, then the argument \code{file_meta}
must be omitted.}

\item{header}{A logical value, which defines if the first row contains
the data headers. If set to \code{TRUE}, then the names given in the data
header will be used as column names instead.}

\item{skip_rows}{The number of rows to be skipped. In the case of DSV or
EXCEL files: If the argument \code{header} is set to \code{TRUE}, then the
first row is always assumed to be the header row.}

\item{na}{A string representing missing values in the data file.}

\item{trim_ws}{A logical value, defining if the character values should
be stipped of all leading and trailing white spaces.}

\item{n_max}{A number, defining the maximum number of rows to be
read. If \code{n_max = Inf}, then  all available rows will be read.}

\item{to_lower}{A logical flag, defining if the names of the columns should
be transformed to lower case after reading the data set (by calling
\code{\link[=read_data]{read_data()}}). This transformation will be applied before comparing the
column names (in the case of SAS-Files or DSV- and EXCE-Files with
\code{header = TRUE}).
In the case of \code{new_file_definition()} the \code{to_lower} argument
overwrites the \code{to_lower} argument in the
\link[=new_file_structure_fwf]{file_structure} class object given in
\code{file_structure}. If \code{to_lower} is omitted, then the \code{file_structure}
class object remains unchanged.
In the case of \code{new_file_definition_fwf()}, \code{new_file_definition_dsv()}, \code{new_file_definition_excel()}
or \code{new_file_definition_sas()} the argument \code{to_lower} must either be \code{TRUE}
or \code{FALSE}.}

\item{rename_cols}{A logical value, which defines if the columns given in
the data file should be overwritten by the columns given in argument
\code{col_names}. If \code{col_names} is not given, then \code{rename_cols} has no
effect.}

\item{adapters}{An optional list argument, holding a list of adapter functions
(See section \emph{adapters}).}

\item{cols_keep}{Either \code{TRUE} or a character vector.
If set to \code{TRUE}, then all columns of the data
are kept when calling \code{\link[=read_data]{read_data()}}.
If \code{cols_keep} character vector, then the values in \code{cols_keep} represent
the names of the columns, which are kept  when calling \code{\link[=read_data]{read_data()}}.}

\item{extra_col_name}{An optional string, which defines the column, which
will be added to the data set (after reading it with function \code{\link[=read_data]{read_data()}}).
Each entry of the column will have the single value given in \code{extra_col_val}.
For example: This column is useful when reading similar data files for
separate years (one could pass the current data set year to \code{extra_col_name}
and set \code{extra_col_name = "year"}).
If \code{extra_col_name} is omitted, no column will be added to the data set and
then \code{extra_col_val} must be omitted as well.
additional column with the column name, given in  \code{extra_col_name}.
If omitted, then no column will be added to the data set and the
argument \code{extra_col_name} must be omitted as well.}

\item{extra_col_val}{An optional value (any atomic type), which will be added
(after reading the data set with function \code{\link[=read_data]{read_data()}}) as an
additional column with the column name, given in  \code{extra_col_name}.
For example: This column is useful when reading similar data files for
separate years (one could pass the current data set year to \code{extra_col_name}
and set \code{extra_col_name = "year"}).
If omitted, then no column will be added to the data set and the
argument \code{extra_col_name} must be omitted as well.}

\item{extra_col_file_path}{Either \code{FALSE} or a string.
If set to \code{FALSE} no file-path-column will be added to the data set, when
calling \code{\link[=read_data]{read_data()}}.
If the argument \code{extra_col_file_path} is a string, then a column holding
the file path of the data file will be added to the read data set, when
calling \code{\link[=read_data]{read_data()}}. The string of \code{extra_col_file_path} will be used
as column name for this additional column.}

\item{err_h}{An error handler}

\item{...}{Additional function arguments for
\itemize{
\item \code{\link[readr:read_fwf]{readr::read_fwf()}} in case of FWF files
\item \code{\link[utils:read.table]{utils::read.delim()}} in case of DSV files
\item \code{\link[readxl:read_excel]{readxl::read_excel()}} in case of EXCEL files
}}
}
\description{
Helper function for \code{new_file_definition_excel()}
}
