% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file_structure.R
\name{new_file_structure_sas_}
\alias{new_file_structure_sas_}
\title{Helper function for \code{\link[=new_file_structure_sas]{new_file_structure_sas()}}}
\usage{
new_file_structure_sas_(
  specification_files = NULL,
  file_meta = NULL,
  skip_rows,
  n_max,
  encoding = NULL,
  to_lower,
  rename_cols,
  retype_cols,
  adapters = new_adapters(),
  err_h,
  class = NULL,
  ...
)
}
\arguments{
\item{specification_files}{An optional character vector holding the paths
to the files, where the file structure is described.}

\item{file_meta}{An optional \link[=new_file_meta]{file_meta} class object,
holding some meta information for each data column
(column description, possible column values + descriptions of possible
column values).
For details see section \strong{meta information}.
If the argument \code{cols} is not \code{NULL}, then the argument \code{file_meta}
must be omitted.}

\item{skip_rows}{The number of rows to be skipped. In the case of DSV or
EXCEL files: If the argument \code{header} is set to \code{TRUE}, then the
first row is always assumed to be the header row.}

\item{n_max}{A number, defining the maximum number of rows to be
read. If \code{n_max = Inf}, then  all available rows will be read.}

\item{encoding}{A string, defining which encoding should be assumed when
reading the data file. The following valuels are allowed:
\itemize{
\item \code{"UTF-8"}: For \emph{UTF-8} encoded files.
\item \code{"latin1"}: For \emph{ISO 8859-1} (also called \emph{Latin-1}) encoded files.
This encoding is almost the same as \emph{Windows-1252} (also called \emph{ANSI}).
They differ only in 32 symbol codes (special symbols that are rarely
used). In the case of SAS files, it is possible to set \code{encoding = NULL}.
In this case, the encoding defined in the SAS data file header
will be used.
}}

\item{to_lower}{A logical flag, defining if the names of the columns should
be transformed to lower case after reading the data set (by calling
\code{\link[=read_data]{read_data()}}). This transformation will be applied before comparing the
column names (in the case of SAS-Files or DSV- and EXCE-Files with
\code{header = TRUE}).}

\item{rename_cols}{A logical value, which defines if the columns given in
the data file should be overwritten by the columns given in argument
\code{col_names}. If \code{col_names} is not given, then \code{rename_cols} has no
effect.}

\item{retype_cols}{A logical value, which defines if the types of the
columns given in SAS file changed to the types given in the
\code{col_types} argument. If \code{col_types} is not given, then \code{retype_cols} has no
effect.}

\item{adapters}{An optional list argument, holding a list of adapter functions
(See section \emph{adapters}).}

\item{err_h}{An error handler}

\item{class}{A character vector holding one of the following class names:
\itemize{
\item \code{"file_structure_fwf"} for FWF file file_structures
\item \code{"file_structure_dsv"} for DSV file file_structures
\item \code{"file_structure_excel"} for EXCEL file file_structures
}}

\item{...}{Additional function arguments for
\itemize{
\item \code{\link[readr:read_fwf]{readr::read_fwf()}} in case of FWF files
\item \code{\link[utils:read.table]{utils::read.delim()}} in case of DSV files
\item \code{\link[readxl:read_excel]{readxl::read_excel()}} in case of EXCEL files
}}
}
\description{
In order to read a data file, you need to create a
\link[=new_file_definition]{file_definitionuration} class object, which holds the path
to the data file and all file file_structures
needed in order to read the data file.
But often multiple files share the same file structure. In this case
it is useful to create a \link[=new_file_structure_fwf]{file_structure} object,
which only holds the file structure definitions and reuse this
file_structure object for creating multiple \link[=new_file_definition]{file_definitionuration}
objects for the different files.
For each file type there is a separate file_structure constructor:
\itemize{
\item \code{new_file_structure_fwf()}: Create a file file_structures for
FWF files. These are data files, where the data is stored in columns
of fixed character width.
\item \code{new_secification_dsv()}: Create a file file_structures for
DSV files. These are data files, where the data is stored in columns,
which are separated by a deliminator character.
\item \code{new_secification_excel()}: Create a file file_structures for
EXCEL files.
\item \code{new_secification_sas()}: Create a file file_structures for
SAS files.
}
}
\section{difference file_structure/file_definition/file_collection}{

The goal of the package \code{readall} is it to read data files. For this
purpose the package offers three different class objects in order to
store meta data about the data files:
\itemize{
\item \link[=new_file_structure_fwf]{file_structure} class objects: Objects of this
class can be used in order to define
all file type specific information (e.g. column positions,
column names, column types, deliminator symbols, rows to skip etc.).
The idea is, that one \code{file_structure} object may valid for several files
and therefore be used to read multiple data files.
\item \link[=new_file_definition]{file_definition} class objects: Objects of this class type
contain all informations in order to read a single specific data file
(path to the data file, file \link[=new_file_structure_fwf]{file_structure} etc.).
A \link[=new_file_definition]{file_definition} class object contains a
\link[=new_file_structure_fwf]{file_structure}, which holds all file type
specific information, but also other informations that are only valid
for this specific file.
\item \link[=new_file_collection]{file_collection} class objects: A
\link[=new_file_collection]{file_collection} class object is simply a list holding
multiple \link[=new_file_definition]{file_definition} class objects.
A \link[=new_file_collection]{file_collection} class object
can be used in order to read several data files at once and concatenate
the data into a single data.frame.
}
}

\section{adapters}{

An adapter function is a function that takes a data.frame as input argument
and returns a modified version of this data.frame.
The adapter functions are stored in an \link[=new_adapters]{adapters}
class object, which is a special list that contains all adapter functions
and a description text of each function. This class objects can be
created by using the function \code{\link[=new_adapters]{new_adapters()}}.
The \link[=new_adapters]{adapters} class objects can be added to a
\link[=new_file_structure_fwf]{file_structure} or a
\link[=new_file_definition]{file_definition} or a \link[=new_file_collection]{file_collection} class object.
After reading a data file (by calling \link[=read_data]{read_data(file_definition)})
all adapter functions listed in the \code{adapters} argument of the
file_definition]\code{\link[=new_file_definition]{new_file_definition()}} class object
will be applied consecutively to the loaded data set.
Adapter functions can be added to an existing
\link[=new_file_structure_fwf]{file_structure} or a \link[=new_file_definition]{file_definition} or
a \link[=new_file_collection]{file_collection} class
object by using the function \code{\link[=add_adapters]{add_adapters()}}.
Adapter functions can be used for several tasks:
\itemize{
\item adapt the data sets in such a way that they can be concatenated for
mutliple years
\item compute new variables from existing variables
\item fix errors in variables
\item transform the values of a variable of an older data set, such that it
complies with a newer variable definition
}
}

\section{File types}{

The function \code{\link[=read_data]{read_data()}} can read read four different types of data
\itemize{
\item \code{FWF}: Fixed width files. This files are text files, where the data is
stored in columns, that have a fixed character width.
\item \code{DSV}: Delimiter-separated value file. This files are text files, where
the data is stored in columns that are separated by a delimiter character.
\item \code{EXCEL}: An excel file holding the data.
\item \code{SAS}: A SAS file holding the data.

In order to read a data file with the function \code{\link[=read_data]{read_data()}},
it is useful to create a \link[=new_file_definition_fwf]{file_definitionuration} or
\link[=new_file_structure_fwf]{file_structure} class object,
holding all needed data file file_structures:
\itemize{
\item \code{\link[=new_file_definition_fwf]{new_file_definition_fwf()}} or \code{\link[=new_file_structure_fwf]{new_file_structure_fwf()}} for \code{FWF} files
\item \code{\link[=new_file_definition_dsv]{new_file_definition_dsv()}} or \code{\link[=new_file_structure_dsv]{new_file_structure_dsv()}} for \code{DSV} files
\item \code{\link[=new_file_definition_excel]{new_file_definition_excel()}} or \code{\link[=new_file_structure_excel]{new_file_structure_excel()}} for \code{Excel} files
\item \code{\link[=new_file_definition_sas]{new_file_definition_sas()}} or \code{\link[=new_file_structure_sas]{new_file_structure_sas()}} for \code{SAS} files
}
}
}

\section{meta information}{

The \link[=new_col_meta]{col_meta} class objects are used in order to store some
meta information about single data columns, like additional column desciptions,
and column value/level descriptions. In order to store meta information
about a set of columns a \link[=new_file_meta]{file_meta} class object can be
used. This objects store a list of \link[=new_col_meta]{col_meta} class objects, where
each \link[=new_col_meta]{col_meta} class object corresponds to a specific column in
a data set. This \link[=new_file_meta]{file_meta} class objects are usually
stored in \link[=new_file_structure_fwf]{file_structure} class objects or
\link[=new_file_definition]{file_definition} class objects. But when calling \code{\link[=read_data]{read_data()}}, the
meta information gets also appended to the resulting \code{data.frame}.
The meta information stored in a \link[=new_file_structure_fwf]{file_structure},
a \link[=new_file_definition]{file_definition} class object or a read \code{data.frame} can be extracted
by using the function \code{\link[=get_meta]{get_meta()}}.
A \link[=new_col_meta]{col_meta} class object holds the following informations:
\itemize{
\item \code{desc}: A string holding the column description.
\item \code{values}: A vector (character/logical/numeric) usually holding
the possible column values (e.g. \code{c(1, 2)}) or a more abstract text
version of the column values (e.g. \code{c("JJJJMMDD", "99999999", "")}).
\item \code{values_desc}: A character vector that corresponds to the \code{values} vector.
Each entry of \code{values_desc} is a more detailed description of the
corresponding entry in \code{values}. If some descriptions are not present,
the entries are \code{NA} values.
}
}

