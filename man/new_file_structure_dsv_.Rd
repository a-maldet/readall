% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file_structure.R
\name{new_file_structure_dsv_}
\alias{new_file_structure_dsv_}
\title{Helper function for \code{\link[=new_file_structure_dsv]{new_file_structure_dsv()}}}
\usage{
new_file_structure_dsv_(
  specification_files = NULL,
  cols = NULL,
  col_names = NULL,
  col_types = NULL,
  file_meta = NULL,
  sep,
  header,
  skip_rows,
  na,
  decimal_mark,
  big_mark,
  trim_ws,
  n_max,
  encoding,
  to_lower,
  rename_cols,
  adapters,
  err_h,
  class = NULL,
  ...
)
}
\arguments{
\item{specification_files}{An optional character vector holding the paths
to the files, where the file structure is described.}

\item{cols}{An optional list argument, holding the column definitions.
This argument can be used instead of the arguments
\code{col_names}, \code{col_types}, \code{col_start}, \code{col_end}, \code{col_widths}, in order
to define the column structure. If the argument \code{cols} is used, then
non of the \verb{col_*} argument are allowed. If so, the \code{cols} argument
has the following structure: It is list, where each list entry fully describes
a single column. Each list entry must have the same subselection of the
following possible list entries:
\itemize{
\item \code{type}: (obligatoric) A string value defining the data type of the column.
The following values are allowed: \code{"character"}, \code{"logical"}, \code{"integer"},
\code{"numeric"} and \code{"NULL"} (for skipping this column). In the case of SAS files
the \code{type} information can be omitted, since the data type information
is stored in the SAS data files, but the argument \code{type} can still
be useful in order to check that the read data column have the expected
data type. For SAS-Files this check is done automatically after reading
the data with \code{\link[=read_data]{read_data()}}.
\item \code{name}: (optional) A string holding the column name.
\item \code{start}: (optional) A number holding the position of the first character of the column.
\item \code{end}: (optional) A number holding the position of the last character of the column.
\item \code{width} (optional) A numeric holding the number characters of the column.
\item \code{col_meta}: (optional) A \link[=new_col_meta]{col_meta} class object, holding some
meta information for the specific column (column description,
possible column values + descriptions of possible column values).
For details see section \strong{meta information}.
}}

\item{col_names}{An optional character vector holding the names of the columns.
If omitted, then the strings \code{"x1"}, \code{"x2"}, ... will be used.
In the case of DSV or EXCEL files: If the argument \code{header} is
set to \code{TRUE}, then the column names given
in the data header will be used instead. If \code{col_names} is also supplied,
then the column names given in the DSV, EXCEL or SAS file will be compared
with the names given in \code{col_names}. Sometimes it is useful, to have the
column names to be automatically transformed to lower case (directly after
reading the date, but before comparing the column names). This can be
achieved by setting \code{to_lower = TRUE}.
Generally, the argument \code{cols} can be used instead, in order to define
the column names. If the argument \code{cols} is not \code{NULL},
then the argument \code{col_names} must be omitted.}

\item{col_types}{A character vector defining the data types for each column.
The following strings are allowed: \code{"character"}, \code{"logical"},
\code{"integer"}, \code{"numeric"} and \code{"NULL"} (for skipping this column).
Generally, the argument \code{cols} can be used instead, in order to define
the column types. If the argument \code{cols} is not \code{NULL},
then the argument \code{col_types} must be omitted. In the case of SAS files
the \code{col_types} information can be omitted, since the data type information
is stored in the SAS data files, but the argument \code{col_types} can still
be useful in order to check the read data files, if the data types are
as expected. For SAS-Files this check is done automatically after reading
the data with \code{\link[=read_data]{read_data()}}}

\item{file_meta}{An optional \link[=new_file_meta]{file_meta} class object,
holding some meta information for each data column
(column description, possible column values + descriptions of possible
column values).
For details see section \strong{meta information}.
If the argument \code{cols} is not \code{NULL}, then the argument \code{file_meta}
must be omitted.}

\item{sep}{A string holding the column deliminator symbol.}

\item{header}{A logical value, which defines if the first row contains
the data headers. If set to \code{TRUE}, then the names given in the data
header will be used as column names instead.}

\item{skip_rows}{The number of rows to be skipped. In the case of DSV or
EXCEL files: If the argument \code{header} is set to \code{TRUE}, then the
first row is always assumed to be the header row.}

\item{na}{A string representing missing values in the data file.}

\item{decimal_mark}{A character, defining the decimal separator in numeric
columns. Only the strings \code{"."} and \code{","} are allowed.}

\item{big_mark}{A character, defining the thousands separator in numeric
columns. Only the strings \code{"."} and \code{","} are allowed.}

\item{trim_ws}{A logical value, defining if the character values should
be stipped of all leading and trailing white spaces.}

\item{n_max}{A number, defining the maximum number of rows to be
read. If \code{n_max = Inf}, then  all available rows will be read.}

\item{encoding}{A string, defining which encoding should be assumed when
reading the data file. The following valuels are allowed:
\itemize{
\item \code{"UTF-8"}: For \emph{UTF-8} encoded files.
\item \code{"latin1"}: For \emph{ISO 8859-1} (also called \emph{Latin-1}) encoded files.
This encoding is almost the same as \emph{Windows-1252} (also called \emph{ANSI}).
They differ only in 32 symbol codes (special symbols that are rarely
used). In the case of SAS files, it is possible to set \code{encoding = NULL}.
In this case, the encoding defined in the SAS data file header
will be used.
}}

\item{to_lower}{A logical flag, defining if the names of the columns should
be transformed to lower case after reading the data set (by calling
\code{\link[=read_data]{read_data()}}). This transformation will be applied before comparing the
column names (in the case of SAS-Files or DSV- and EXCE-Files with
\code{header = TRUE}).}

\item{rename_cols}{A logical value, which defines if the columns given in
the data file should be overwritten by the columns given in argument
\code{col_names}. If \code{col_names} is not given, then \code{rename_cols} has no
effect.}

\item{adapters}{An optional list argument, holding a list of adapter functions
(See section \emph{adapters}).}

\item{err_h}{An error handler}

\item{class}{A character vector holding one of the following class names:
\itemize{
\item \code{"file_structure_fwf"} for FWF file file_structures
\item \code{"file_structure_dsv"} for DSV file file_structures
\item \code{"file_structure_excel"} for EXCEL file file_structures
}}

\item{...}{Additional function arguments for
\itemize{
\item \code{\link[readr:read_fwf]{readr::read_fwf()}} in case of FWF files
\item \code{\link[utils:read.table]{utils::read.delim()}} in case of DSV files
\item \code{\link[readxl:read_excel]{readxl::read_excel()}} in case of EXCEL files
}}
}
\description{
In order to read a data file, you need to create a
\link[=new_file_definition]{file_definitionuration} class object, which holds the path
to the data file and all file file_structures
needed in order to read the data file.
But often multiple files share the same file structure. In this case
it is useful to create a \link[=new_file_structure_fwf]{file_structure} object,
which only holds the file structure definitions and reuse this
file_structure object for creating multiple \link[=new_file_definition]{file_definitionuration}
objects for the different files.
For each file type there is a separate file_structure constructor:
\itemize{
\item \code{new_file_structure_fwf()}: Create a file file_structures for
FWF files. These are data files, where the data is stored in columns
of fixed character width.
\item \code{new_secification_dsv()}: Create a file file_structures for
DSV files. These are data files, where the data is stored in columns,
which are separated by a deliminator character.
\item \code{new_secification_excel()}: Create a file file_structures for
EXCEL files.
\item \code{new_secification_sas()}: Create a file file_structures for
SAS files.
}
}
\section{difference file_structure/file_definition/file_collection}{

The goal of the package \code{readall} is it to read data files. For this
purpose the package offers three different class objects in order to
store meta data about the data files:
\itemize{
\item \link[=new_file_structure_fwf]{file_structure} class objects: Objects of this
class can be used in order to define
all file type specific information (e.g. column positions,
column names, column types, deliminator symbols, rows to skip etc.).
The idea is, that one \code{file_structure} object may valid for several files
and therefore be used to read multiple data files.
\item \link[=new_file_definition]{file_definition} class objects: Objects of this class type
contain all informations in order to read a single specific data file
(path to the data file, file \link[=new_file_structure_fwf]{file_structure} etc.).
A \link[=new_file_definition]{file_definition} class object contains a
\link[=new_file_structure_fwf]{file_structure}, which holds all file type
specific information, but also other informations that are only valid
for this specific file.
\item \link[=new_file_collection]{file_collection} class objects: A
\link[=new_file_collection]{file_collection} class object is simply a list holding
multiple \link[=new_file_definition]{file_definition} class objects.
A \link[=new_file_collection]{file_collection} class object
can be used in order to read several data files at once and concatenate
the data into a single data.frame.
}
}

\section{adapters}{

An adapter function is a function that takes a data.frame as input argument
and returns a modified version of this data.frame.
The adapter functions are stored in an \link[=new_adapters]{adapters}
class object, which is a special list that contains all adapter functions
and a description text of each function. This class objects can be
created by using the function \code{\link[=new_adapters]{new_adapters()}}.
The \link[=new_adapters]{adapters} class objects can be added to a
\link[=new_file_structure_fwf]{file_structure} or a
\link[=new_file_definition]{file_definition} or a \link[=new_file_collection]{file_collection} class object.
After reading a data file (by calling \link[=read_data]{read_data(file_definition)})
all adapter functions listed in the \code{adapters} argument of the
file_definition]\code{\link[=new_file_definition]{new_file_definition()}} class object
will be applied consecutively to the loaded data set.
Adapter functions can be added to an existing
\link[=new_file_structure_fwf]{file_structure} or a \link[=new_file_definition]{file_definition} or
a \link[=new_file_collection]{file_collection} class
object by using the function \code{\link[=add_adapters]{add_adapters()}}.
Adapter functions can be used for several tasks:
\itemize{
\item adapt the data sets in such a way that they can be concatenated for
mutliple years
\item compute new variables from existing variables
\item fix errors in variables
\item transform the values of a variable of an older data set, such that it
complies with a newer variable definition
}
}

\section{File types}{

The function \code{\link[=read_data]{read_data()}} can read read four different types of data
\itemize{
\item \code{FWF}: Fixed width files. This files are text files, where the data is
stored in columns, that have a fixed character width.
\item \code{DSV}: Delimiter-separated value file. This files are text files, where
the data is stored in columns that are separated by a delimiter character.
\item \code{EXCEL}: An excel file holding the data.
\item \code{SAS}: A SAS file holding the data.

In order to read a data file with the function \code{\link[=read_data]{read_data()}},
it is useful to create a \link[=new_file_definition_fwf]{file_definitionuration} or
\link[=new_file_structure_fwf]{file_structure} class object,
holding all needed data file file_structures:
\itemize{
\item \code{\link[=new_file_definition_fwf]{new_file_definition_fwf()}} or \code{\link[=new_file_structure_fwf]{new_file_structure_fwf()}} for \code{FWF} files
\item \code{\link[=new_file_definition_dsv]{new_file_definition_dsv()}} or \code{\link[=new_file_structure_dsv]{new_file_structure_dsv()}} for \code{DSV} files
\item \code{\link[=new_file_definition_excel]{new_file_definition_excel()}} or \code{\link[=new_file_structure_excel]{new_file_structure_excel()}} for \code{Excel} files
\item \code{\link[=new_file_definition_sas]{new_file_definition_sas()}} or \code{\link[=new_file_structure_sas]{new_file_structure_sas()}} for \code{SAS} files
}
}
}

\section{meta information}{

The \link[=new_col_meta]{col_meta} class objects are used in order to store some
meta information about single data columns, like additional column desciptions,
and column value/level descriptions. In order to store meta information
about a set of columns a \link[=new_file_meta]{file_meta} class object can be
used. This objects store a list of \link[=new_col_meta]{col_meta} class objects, where
each \link[=new_col_meta]{col_meta} class object corresponds to a specific column in
a data set. This \link[=new_file_meta]{file_meta} class objects are usually
stored in \link[=new_file_structure_fwf]{file_structure} class objects or
\link[=new_file_definition]{file_definition} class objects. But when calling \code{\link[=read_data]{read_data()}}, the
meta information gets also appended to the resulting \code{data.frame}.
The meta information stored in a \link[=new_file_structure_fwf]{file_structure},
a \link[=new_file_definition]{file_definition} class object or a read \code{data.frame} can be extracted
by using the function \code{\link[=get_meta]{get_meta()}}.
A \link[=new_col_meta]{col_meta} class object holds the following informations:
\itemize{
\item \code{desc}: A string holding the column description.
\item \code{values}: A vector (character/logical/numeric) usually holding
the possible column values (e.g. \code{c(1, 2)}) or a more abstract text
version of the column values (e.g. \code{c("JJJJMMDD", "99999999", "")}).
\item \code{values_desc}: A character vector that corresponds to the \code{values} vector.
Each entry of \code{values_desc} is a more detailed description of the
corresponding entry in \code{values}. If some descriptions are not present,
the entries are \code{NA} values.
}
}

