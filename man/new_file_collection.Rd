% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/file_collection.R
\name{new_file_collection}
\alias{new_file_collection}
\title{Create a list of file_definitionuration objects}
\usage{
new_file_collection(
  ...,
  to_lower = NULL,
  cols_keep = NULL,
  extra_col_file_path = NULL,
  extra_adapters = new_adapters()
)
}
\arguments{
\item{...}{Multiple file file_definitionurations. This file file_definitionurations can be
created with the functions \code{\link[=new_file_definition]{new_file_definition()}}, \code{\link[=new_file_definition_fwf]{new_file_definition_fwf()}},
\code{\link[=new_file_definition_dsv]{new_file_definition_dsv()}}, \code{\link[=new_file_definition_excel]{new_file_definition_excel()}} or \code{\link[=new_file_definition_sas]{new_file_definition_sas()}}
depending on the given file type.}

\item{to_lower}{An optional logical argument.
If omitted, then the \code{to_lower} arguments in the file_definitionurations
given in \code{...} remain unchanged. If \code{to_lower} is not omitted,
then for each file_definitionuration the argument \code{to_lower} will be
updated with the new value.
The \code{to_lower} argument defines if the names of the columns should
be transformed to lower case after reading the data set (by calling
\code{\link[=read_data]{read_data()}}). This transformation will be applied before comparing the
column names (in the case of SAS-Files or DSV- and EXCE-Files with
\code{header = TRUE}).}

\item{cols_keep}{An optional argument, which can either be \code{TRUE} or
a character vector. If the argument is omitted (\code{NULL}), then the
\code{cols_keep} arguments of all \code{file_collection} entries will stay unchanged.
If the argument \code{cols_keep} is not \code{NULL}, then its value will overwrite
the \code{cols_keep} argument of each \code{file_collection} entry.
If the \code{cols_keep} argument is set to \code{TRUE}, then all columns of each
data set will be kept when calling \code{\link[=read_data]{read_data()}}.
If \code{cols_keep} is a character vector, then the values in \code{cols_keep}
represent the names of the columns, which will be kept, when calling
\code{\link[=read_data]{read_data()}}.}

\item{extra_col_file_path}{An optional argument, which can either be
\code{FALSE} or a string. If the argument is omitted (\code{NULL}), then the
\code{extra_col_file_path} argument of each \code{file_collection} entry will stay
unchanged.
If the argument \code{extra_col_file_path} is not \code{NULL}, then its value will
overwrite the \code{extra_col_file_path} argument of each \code{file_collection} entry.
If set to \code{FALSE} no file-path-column will be added to the data sets, when
calling \code{\link[=read_data]{read_data()}}.
If the argument \code{extra_col_file_path} is a string, then a column holding
the file path of each data file will be added to the read data sets, when
calling \code{\link[=read_data]{read_data()}}. The string of \code{extra_col_file_path} will be used
as column name for this additional column.}

\item{extra_adapters}{An optional \link[=new_adapters]{adapters} class object,
which holds a list of adapter functions. These adapter functions will
be added to the adapter functions already stored in each file
\link[=new_file_definition]{file_definitionuration} passed in via \code{...}. For further details
on adapter functions see section \emph{adapters}.}
}
\value{
A list, where each list entry is file \link[=new_file_definition]{file_definitionuration},
which holds all information needed to read a specific data file with the
function \code{\link[=read_data]{read_data()}}.
}
\description{
With the function \code{\link[=read_data]{read_data()}} you can read FWF-, DSV-, EXCEL- or SAS data files
and store the data in a data.frame.
But with \code{\link[=read_data]{read_data()}} you can also read multiple data files
at once and automatically concatenate
the resulting data.frames into a single data.frame. In order to do so,
you need to create a
list of \verb{[file_definition class][new_file_definition()]} objects.
This \verb{file_definitionuration list} is a \code{file_collection} class object and each
list entry a \link[=new_file_definition]{file_definition class} class object holding all
information needed for reading a specific data file.
Each file_definitionuration list entry can be created by using one of the following
functions:
\itemize{
\item \code{\link[=new_file_definition]{new_file_definition()}} for FWF, DSV or EXCEL data files
\item \code{\link[=new_file_definition_fwf]{new_file_definition_fwf()}} for FWF data files
\item \code{\link[=new_file_definition_dsv]{new_file_definition_dsv()}} for DSV data files
\item \code{\link[=new_file_definition_excel]{new_file_definition_excel()}} for EXCEL data files
\item \code{\link[=new_file_definition_sas]{new_file_definition_sas()}} for SAS data files
}
}
\section{File types}{

The function \code{\link[=read_data]{read_data()}} can read read four different types of data
\itemize{
\item \code{FWF}: Fixed width files. This files are text files, where the data is
stored in columns, that have a fixed character width.
\item \code{DSV}: Delimiter-separated value file. This files are text files, where
the data is stored in columns that are separated by a delimiter character.
\item \code{EXCEL}: An excel file holding the data.
\item \code{SAS}: A SAS file holding the data.

In order to read a data file with the function \code{\link[=read_data]{read_data()}},
it is useful to create a \link[=new_file_definition_fwf]{file_definitionuration} or
\link[=new_file_structure_fwf]{file_structure} class object,
holding all needed data file file_structures:
\itemize{
\item \code{\link[=new_file_definition_fwf]{new_file_definition_fwf()}} or \code{\link[=new_file_structure_fwf]{new_file_structure_fwf()}} for \code{FWF} files
\item \code{\link[=new_file_definition_dsv]{new_file_definition_dsv()}} or \code{\link[=new_file_structure_dsv]{new_file_structure_dsv()}} for \code{DSV} files
\item \code{\link[=new_file_definition_excel]{new_file_definition_excel()}} or \code{\link[=new_file_structure_excel]{new_file_structure_excel()}} for \code{Excel} files
\item \code{\link[=new_file_definition_sas]{new_file_definition_sas()}} or \code{\link[=new_file_structure_sas]{new_file_structure_sas()}} for \code{SAS} files
}
}
}

\section{difference file_structure/file_definition/file_collection}{

The goal of the package \code{readall} is it to read data files. For this
purpose the package offers three different class objects in order to
store meta data about the data files:
\itemize{
\item \link[=new_file_structure_fwf]{file_structure} class objects: Objects of this
class can be used in order to define
all file type specific information (e.g. column positions,
column names, column types, deliminator symbols, rows to skip etc.).
The idea is, that one \code{file_structure} object may valid for several files
and therefore be used to read multiple data files.
\item \link[=new_file_definition]{file_definition} class objects: Objects of this class type
contain all informations in order to read a single specific data file
(path to the data file, file \link[=new_file_structure_fwf]{file_structure} etc.).
A \link[=new_file_definition]{file_definition} class object contains a
\link[=new_file_structure_fwf]{file_structure}, which holds all file type
specific information, but also other informations that are only valid
for this specific file.
\item \link[=new_file_collection]{file_collection} class objects: A
\link[=new_file_collection]{file_collection} class object is simply a list holding
multiple \link[=new_file_definition]{file_definition} class objects.
A \link[=new_file_collection]{file_collection} class object
can be used in order to read several data files at once and concatenate
the data into a single data.frame.
}
}

\section{adapters}{

An adapter function is a function that takes a data.frame as input argument
and returns a modified version of this data.frame.
The adapter functions are stored in an \link[=new_adapters]{adapters}
class object, which is a special list that contains all adapter functions
and a description text of each function. This class objects can be
created by using the function \code{\link[=new_adapters]{new_adapters()}}.
The \link[=new_adapters]{adapters} class objects can be added to a
\link[=new_file_structure_fwf]{file_structure} or a
\link[=new_file_definition]{file_definition} or a \link[=new_file_collection]{file_collection} class object.
After reading a data file (by calling \link[=read_data]{read_data(file_definition)})
all adapter functions listed in the \code{adapters} argument of the
file_definition]\code{\link[=new_file_definition]{new_file_definition()}} class object
will be applied consecutively to the loaded data set.
Adapter functions can be added to an existing
\link[=new_file_structure_fwf]{file_structure} or a \link[=new_file_definition]{file_definition} or
a \link[=new_file_collection]{file_collection} class
object by using the function \code{\link[=add_adapters]{add_adapters()}}.
Adapter functions can be used for several tasks:
\itemize{
\item adapt the data sets in such a way that they can be concatenated for
mutliple years
\item compute new variables from existing variables
\item fix errors in variables
\item transform the values of a variable of an older data set, such that it
complies with a newer variable definition
}


An adapter function is a function that takes a data.frame as input argument
and returns a modified version of this data.frame.
The adapter functions are stored in an \link[=new_adapters]{adapters}
class object, which is a special list that contains all adapter functions
and a description text of each function. This class objects can be
created by using the function \code{\link[=new_adapters]{new_adapters()}}.
The \link[=new_adapters]{adapters} class objects can be added to a
\link[=new_file_structure_fwf]{file_structure} or a
\link[=new_file_definition]{file_definition} or a \link[=new_file_collection]{file_collection} class object.
After reading a data file (by calling \link[=read_data]{read_data(file_definition)})
all adapter functions listed in the \code{adapters} argument of the
file_definition]\code{\link[=new_file_definition]{new_file_definition()}} class object
will be applied consecutively to the loaded data set.
Adapter functions can be added to an existing
\link[=new_file_structure_fwf]{file_structure} or a \link[=new_file_definition]{file_definition} or
a \link[=new_file_collection]{file_collection} class
object by using the function \code{\link[=add_adapters]{add_adapters()}}.
Adapter functions can be used for several tasks:
\itemize{
\item adapt the data sets in such a way that they can be concatenated for
mutliple years
\item compute new variables from existing variables
\item fix errors in variables
\item transform the values of a variable of an older data set, such that it
complies with a newer variable definition
}
}

