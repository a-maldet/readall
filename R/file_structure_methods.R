#' @include file_structure.R
NULL

#' Helper function for `read_data()`: Generate `locale` object for [readr::read_fwf()]
#' 
#' @param obj A [file_structure][new_file_structure_fwf()] class or a 
#'   [file_definition][new_file_definition()] class object, that holds all informations needed for
#'   reading a specific data set.
#' @param ... Optional error handler
#' @return An object generated by `readr::default_locale()`
get_fwf_locale <- function(
  obj,
  ...
) {
  args <- list(
    encoding = if (!is.null(obj$encoding)) get_encoding(obj) else NULL,
    decimal_mark = if (!is.null(obj$decimal_mark)) obj$decimal_mark else NULL,
    grouping_mark = if (!is.null(obj$big_mark)) obj$grouping_mark else NULL
  )
  args <- args[!sapply(args, is.null)]
  x <- do.call(
    readr::locale,
    args = args
  )
  x
}

#' Helper function for `read_data()`: Generate `col_positions` object for [readr::read_fwf()]
#' 
#' @inheritParams get_fwf_locale
#' @param err_h An error handler
#' @return An object generated by `readr::fwf_positions()`
get_fwf_col_positions <- function(
  obj,
  err_h = composerr("Error while calling 'get_fwf_col_positions()'")
) {
  err_h <- composerr(
    paste(
      "Column positions could not be calculated, since the structure",
      "was not defined correctly"
    ),
    err_h
  )
  sep_width <- obj$sep_width
  start <- obj$col_start
  end <- obj$col_end
  widths <- obj$col_widths
  if (!is.null(widths)) {
    if (!is.null(sep_width)) {
      start <- c(1, 1 + cumsum(widths[seq_len(length(widths)-1)] + sep_width))
    } else if (!is.null(end)) {
      start <- end - widths + 1
    } else if (is.null(start)) {
      err_h()
    }
    end <- start + widths - 1
  } else if (!is.null(start)) {
    if (!is.null(sep_width)) {
      end <- c(start[2:length(start)] - sep_width - 1, NA)
    } else if (is.null(end)) {
      err_h()
    }
  } else if (!is.null(end)) {
    if (!is.null(sep_width)) {
      start <- c(1, end[seq_len(length(end) - 1)] + sep_width + 1)
    } else {
      err_h()
    }
  }
  readr::fwf_positions(start = start, end = end, col_names = obj$col_names)
}

#' Get the specified file type
#' 
#' @section File types:
#' The function [read_data()] can read read four different types of data
#' - `FWF`: Fixed width files. This files are text files, where the data is
#'   stored in columns, that have a fixed character width.
#' - `DSV`: Delimiter-separated value file. This files are text files, where
#'   the data is stored in columns that are separated by a delimiter character.
#' - `EXCEL`: An excel file holding the data.
#' - `SAS`: A SAS file holding the data.
#' 
#'   In order to read a data file with the function [read_data()],
#'   it is useful to create a [file_definitionuration][new_file_definition_fwf()] or
#'   [file_structure][new_file_structure_fwf()] class object, 
#'   holding all needed data file file_structures:
#'   - [new_file_definition_fwf()] or [new_file_structure_fwf()] for `FWF` files
#'   - [new_file_definition_dsv()] or [new_file_structure_dsv()] for `DSV` files
#'   - [new_file_definition_excel()] or [new_file_structure_excel()] for `Excel` files
#'   - [new_file_definition_sas()] or [new_file_structure_sas()] for `SAS` files
#' @inheritParams get_fwf_locale
#' @return A string holding the file type defined in `obj`
#' @export
#' @rdname get_file_type
get_file_type <- function(obj, ...) UseMethod("get_file_type")

#' Missing class for [get_file_type()]
#' 
#' @inheritParams get_file_type
#' @param err_h An error handler
#' @export
get_file_type.default <- function(
  obj,
  err_h = composerr("Error while calling 'get_file_type()'"),
  ...
) {
  err_file_definition(err_h)
}

#' @export
#' @rdname get_file_type
get_file_type.file_structure_fwf <- function(obj, ...) enum_file_types$fwf

#' @export
#' @rdname get_file_type
get_file_type.file_structure_dsv <- function(obj, ...) enum_file_types$dsv

#' @export
#' @rdname get_file_type
get_file_type.file_structure_excel <- function(obj, ...) enum_file_types$excel

#' @export
#' @rdname get_file_type
get_file_type.file_structure_sas <- function(obj, ...) enum_file_types$sas

#' Helper function for `read_data()`: Generate `col_names` object
#' 
#' @inheritParams get_fwf_locale
#' @param ... Optional error handler
#' @rdname get_col_names
#' @return A character vector holding the column names. If no column names
#'   are defined, then the column names are replaced by the values `x1`, `x2`, ... 
#'   Exception for EXCEL file types: If `header = TRUE`, then the value `TRUE`
#'   is returned.
#' @export
get_col_names <- function(obj, ...) UseMethod("get_col_names")

#' Missing class for [get_col_names()]
#' 
#' @inheritParams get_col_names
#' @param err_h An error handler
#' @export
get_col_names.default <- function(
  obj,
  err_h = composerr("Error while calling 'get_col_names()'"),
  ...
) {
  err_file_definition(err_h)
}

#' @rdname get_col_names
#' @export
get_col_names.file_structure_fwf <- function(obj, ...) {
  if (!is.null(obj$col_names)) {
    obj$col_names 
  } else {
    paste0("x", seq_len(length(obj$col_types)))
  }
}

#' @rdname get_col_names
#' @export
get_col_names.file_structure_dsv <- function(
  obj,
  ...
) {
  if (isTRUE(obj$header)) {
    TRUE
  } else {
    if (is.null(obj$col_names)) {
      paste0(
        "x",
        seq_len(length(obj$col_types[obj$col_types != enum_col_types$skip]))
      )
    } else {
      obj$col_names[obj$col_types != enum_col_types$skip]
    }
  }
}

#' @rdname get_col_names
#' @export
get_col_names.file_structure_excel <- function(obj, ...) {
  if (isTRUE(obj$header)) {
    TRUE
  } else {
    if (is.null(obj$col_names)) {
      paste0(
        "x",
        seq_len(length(obj$col_types[obj$col_types != enum_col_types$skip]))
      )
    } else {
      obj$col_names[obj$col_types != enum_col_types$skip]
    }
  }
}

#' Helper function for `read_data()`: Calculate the skipped rows
#' 
#' Currently there is nothing to calculate since `skip` is returned as it is,
#' no matter what values are in `header` and `col_names`.
#' @inheritParams get_fwf_locale
#' @param ... Optional error handler
#' @rdname get_skip_rows
get_skip_rows <- function(obj, ...) UseMethod("get_skip_rows")

#' Missing class for [get_skip_rows()]
#' 
#' @inheritParams get_skip_rows
#' @param err_h An error handler
#' @export
get_skip_rows.default <- function(
  obj,
  err_h = composerr("Error while calling 'get_skip_rows()'")
) {
  err_file_definition(err_h)
}

#' @rdname get_skip_rows
#' @export
get_skip_rows.file_structure_fwf <- function(obj, ...) {
  obj$skip_rows
}

#' @rdname get_skip_rows
#' @export
get_skip_rows.file_structure_dsv <- function(obj, ...) {
  obj$skip_rows
}

#' @rdname get_skip_rows
#' @export
get_skip_rows.file_structure_excel <- function(obj, ...) {
  if (isTRUE(obj$header) && !is.null(obj$col_names))
    return(obj$skip_rows + 1)
  obj$skip_rows
}

#' @rdname get_skip_rows
#' @export
get_skip_rows.file_structure_sas <- function(obj, ...) {
  obj$skip_rows
}

#' Helper function for `read_data()`: Generate `col_types` object
#' 
#' @inheritParams get_col_names
#' @rdname get_col_types
#' @return A character vector holding the type names of each column needed
#'   for the file type specific reading function.
get_col_types <- function(obj, ...) UseMethod("get_col_types")

#' Missing class for [get_col_types()]
#' 
#' @param err_h An error handler
#' @inheritParams get_col_types
#' @export
get_col_types.default <- function(
  obj,
  err_h = composerr("Error while calling 'get_col_types()'")
) {
  err_file_definition(err_h)
}

#' @rdname get_col_types
#' @export
get_col_types.file_structure_fwf <- function(obj, ...) {
  x <- obj$col_types
  x[x == enum_col_types$character] <- "c"
  x[x == enum_col_types$numeric] <- "n"
  x[x == enum_col_types$integer] <- "n"
  x[x == enum_col_types$logical] <- "l"
  x[x == enum_col_types$skip] <- "_"
  paste(x, collapse = "")
}

#' @rdname get_col_types
#' @export
get_col_types.file_structure_dsv <- function(obj, ...) {
  x <- obj$col_types
  x[x == enum_col_types$character] <- "c"
  x[x == enum_col_types$numeric] <- "n"
  x[x == enum_col_types$integer] <- "n"
  x[x == enum_col_types$logical] <- "l"
  x[x == enum_col_types$skip] <- "_"
  paste(x, collapse = "")
}

#' @rdname get_col_types
#' @export
get_col_types.file_structure_excel <- function(obj, ...) {
  x <- obj$col_types
  x[x == enum_col_types$character] <- "text"
  x[x %in% c(enum_col_types$numeric, enum_col_types$integer)] <- "numeric"
  x[x == enum_col_types$logical] <- "logical"
  x[x == enum_col_types$skip] <- "skip"
  x
}

#' Helper function for `read_data()`: Generate encoding string
#' 
#' @inheritParams get_col_names
#' @rdname get_encoding
get_encoding <- function(obj, ...) UseMethod("get_encoding")

#' Missing class for [get_encoding()]
#' 
#' @param err_h An error handler
#' @inheritParams get_encoding
#' @export
get_encoding.default <- function(
  obj,
  err_h = composerr("Error while calling 'get_encoding()'")
) {
  err_file_definition(err_h)
}

#' @rdname get_encoding
#' @export
get_encoding.file_structure_fwf <- function(obj, ...) {
  x <- obj$encoding
  if (is.null(x))
    return(NULL)
  if (x == enum_encodings$utf8) {
    "UTF-8"
  } else if (x == enum_encodings$latin1) {
    "latin1"
  }
}

#' @rdname get_encoding
#' @export
get_encoding.file_structure_dsv <- function(obj, ...) {
  x <- obj$encoding
  if (is.null(x))
    return(NULL)
  if (x == enum_encodings$utf8) {
    "UTF-8"
  } else if (x == enum_encodings$latin1) {
    "latin1"
  }
}

#' @rdname get_encoding
#' @export
get_encoding.file_structure_sas <- function(obj, ...) {
  x <- obj$encoding
  if (is.null(x))
    return(NULL)
  if (x == enum_encodings$utf8) {
    "UTF-8"
  } else if (x == enum_encodings$latin1) {
    "latin1"
  }
}

#' Print [file_structure][new_file_structure_fwf()] class objects
#' 
#' Print [file_definition][new_file_definition()] class objects
#'
#' @param x The list that should be printed
#' @param indent A counter, defining the indentation level
#' @param ... additional arguments
#' @export
print.file_structure <- function(x, indent = 0, ...) {
  if (indent == 0) {
    paste0("### ", get_file_type(x), "-File-Spezifikation ###\n") %>%
      cat
  } else {
    paste0(get_file_type(x), "-File-Spezifikation:\n")%>%
      cat
  }
  print_file_structure(x, indent = indent)
}

#' Helper function for [print.file_structure()] and [print.file_definition()]
#' 
#' @param x The list that should be printed
#' @param indent A counter, defining the indentation level
print_file_structure <- function(x, indent = 0) {
  vars <- names(x)
  col_vars <- list(
    "name" = "col_names",
    "type" = "col_types",
    "start" = "col_start",
    "end" = "col_end",
    "width" = "col_widths",
    "desc" = "file_meta"
  )
  if (any(lapply(col_vars, function(cv) !is.null(x[[cv]])) %>% unlist)) {
    vars <- c(vars, "columns")
  }
  vars <- setdiff(vars, setdiff(col_vars %>% unlist, "file_meta"))
  vars <- order_infront(
    vars,
    c(
      "file_path", "specification_files", "sheet", "range",
      "columns", "sep_width", "sep",
      "header", "skip_rows",
      "na", "decimal_mark", "big_mark", "trim_ws",
      "n_max", "encoding", "adapters",
      "cols_keep", "extra_col_name", "extra_col_val", "extra_col_file_path"
    )
  )
  lapply(
    vars,
    function(var) {
      paste(c(rep("  ", indent + 1), var, ": "), collapse = "") %>% cat
      if (var == "adapters") {
        print(x[[var]], indent = indent + 1)
      } else if (var == "file_meta") {
        if (is.null(x[[var]])) {
          cat("NULL")  
        } else {
          cat("\n")
          get_meta(x) %>%
            print(max = 1000, row.names = FALSE) %>%
            (utils::capture.output) %>%
            paste0(paste(rep("  ", indent + 2), collapse = ""), .) %>%
            cat(sep = "\n")
        }
      } else if (var == "columns") {
        cat("\n")
        lapply(
          col_vars,
          function(cv) {
            if (is.null(x[[cv]]))
              return(NULL)
            if (cv == "file_meta") {
              ret <- lapply(
                x$file_meta,
                function(col_meta) {
                  if (is.null(col_meta$desc))
                    return(NA_character_)
                  col_meta$desc
                }
              ) %>% unlist
            } else {
              ret <- x[[cv]]
            }
            if (is.character(ret)) {
              ret <- sapply(ret, function(y) {
                  if (is.na(y)) {
                    NA_character_
                  } else {
                    stringify(y)
                  }
                }
              ) %>% unlist
            } else {
              ret <- as.character(ret)
            }
            names(ret) <- NULL
            ret
          }
        ) %>%
          remove_null_entries %>%
          data.frame %>%
          print(max = 1000, row.names = TRUE) %>%
          (utils::capture.output) %>%
          paste0(paste(rep("  ", indent + 2), collapse = ""), .) %>%
          cat(sep = "\n")
      } else {
        if (is.null(x[[var]])) {
          val <- "NULL"
        } else if (is.character(x[[var]])) {
          val <- sapply(
            x[[var]],
            function(y) {
              if (is.na(y)) {
                NA_character_
              } else {
                stringify(y)
              }
            }
          ) %>% unlist
        } else {
          val <- as.character(x[[var]])
        }
        if (length(val) == 1) {
          cat(val)
        } else {
          cat("\n")
          paste0(paste(rep("  ", indent + 2), collapse = ""), val) %>%
            cat(sep = "\n")
        }
        cat("\n")
      }
    }
  ) %>% invisible
}
